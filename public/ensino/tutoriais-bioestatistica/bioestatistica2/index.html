<!doctype html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>Bioestatística com R - 2 - Usando e manipulando tabelas // Kleber Neves</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.144.1">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Kleber Neves" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.f314e3ffa0170af43e31c210ec0343b6b8591cd5904e9e934b6588719fd8425e.css" />
    
    <script defer src="https://cloud.umami.is/script.js" data-website-id="3f649046-a4b1-4030-9c81-4bdfc09d9f00"></script>
    
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Bioestatística com R - 2 - Usando e manipulando tabelas">
  <meta name="twitter:description" content="Nesse segundo tutorial, o foco é em importação e exportação de dados pra arquivos, além de como fazer as manipulações mais comuns nas suas tabelas: filtrar de acordo com critérios, criar, renomear e remover colunas, extrair resumos dos dados, entre outras coisas mais. Todas as tabelas usadas nos exemplos estão nessa pasta compartilhada.
Parte 1
Parte 2
Parte 3
Parte 4
Importando e exportando dados Vamos começar do que é mais direto. Digamos que você tem um conjunto de dados que quer salvar num arquivo. Pra fins de armazenamento de dados nesse tutorial, vamos usar arquivos CSV (comma-separated values, de valores separados por vírgulas). Esses arquivos são arquivos texto normais, onde cada linha do arquivo vira uma linha da tabela e as colunas são separadas por vírgulas (ou qualquer outro caractere, digamos, ponto-e-vírgula). Então, podemos criar um conjunto de dados arbitrário em R. Conjuntos de dados são armazenados em variáveis do tipo data.frame. Pra criar um, você pode usar vetores como colunas:">

    <meta property="og:url" content="http://localhost:1313/ensino/tutoriais-bioestatistica/bioestatistica2/">
  <meta property="og:site_name" content="Kleber Neves">
  <meta property="og:title" content="Bioestatística com R - 2 - Usando e manipulando tabelas">
  <meta property="og:description" content="Nesse segundo tutorial, o foco é em importação e exportação de dados pra arquivos, além de como fazer as manipulações mais comuns nas suas tabelas: filtrar de acordo com critérios, criar, renomear e remover colunas, extrair resumos dos dados, entre outras coisas mais. Todas as tabelas usadas nos exemplos estão nessa pasta compartilhada.
Parte 1
Parte 2
Parte 3
Parte 4
Importando e exportando dados Vamos começar do que é mais direto. Digamos que você tem um conjunto de dados que quer salvar num arquivo. Pra fins de armazenamento de dados nesse tutorial, vamos usar arquivos CSV (comma-separated values, de valores separados por vírgulas). Esses arquivos são arquivos texto normais, onde cada linha do arquivo vira uma linha da tabela e as colunas são separadas por vírgulas (ou qualquer outro caractere, digamos, ponto-e-vírgula). Então, podemos criar um conjunto de dados arbitrário em R. Conjuntos de dados são armazenados em variáveis do tipo data.frame. Pra criar um, você pode usar vetores como colunas:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="ensino">
    <meta property="article:published_time" content="2017-07-25T12:19:42+00:00">
    <meta property="article:modified_time" content="2017-07-25T12:19:42+00:00">


  </head>
  <body>
    <header class="app-header">
      <a href="http://localhost:1313/"><img class="app-header-avatar" src="/img/foto-home.jpg" alt="Kleber Neves" /></a>
      <span class="app-header-title">Kleber Neves</span>
      <p>Metacientista e gestor de ciência</p>
      <div class="app-header-social">
        
          <a href="https://www.linkedin.com/in/kleber-neves-03290830/" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-linkedin" viewBox="0 0 24 24" fill="currentColor"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
          </a>
        
          <a href="https://github.com/KleberNeves" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://scholar.google.com.br/citations?user=j_Qu3R8AAAAJ&amp;hl=en" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-googlescholar" viewBox="0 0 24 24" fill="currentColor"><title>Google Scholar</title><path d="M5.242 13.769L0 9.5 12 0l12 9.5-5.242 4.269C17.548 11.249 14.978 9.5 12 9.5c-2.977 0-5.548 1.748-6.758 4.269zM12 10a7 7 0 1 0 0 14 7 7 0 0 0 0-14z"/></svg>
          </a>
        
          <a href="https://orcid.org/0000-0001-9519-4909" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-orcid" viewBox="0 0 24 24" fill="currentColor"><title>ORCID</title><path d="M12 0C5.372 0 0 5.372 0 12s5.372 12 12 12 12-5.372 12-12S18.628 0 12 0zM7.369 4.378c.525 0 .947.431.947.947s-.422.947-.947.947a.95.95 0 0 1-.947-.947c0-.525.422-.947.947-.947zm-.722 3.038h1.444v10.041H6.647V7.416zm3.562 0h3.9c3.712 0 5.344 2.653 5.344 5.025 0 2.578-2.016 5.025-5.325 5.025h-3.919V7.416zm1.444 1.303v7.444h2.297c3.272 0 4.022-2.484 4.022-3.722 0-2.016-1.284-3.722-4.097-3.722h-2.222z"/></svg>
          </a>
        
          <a href="http://buscatextual.cnpq.br/buscatextual/visualizacv.do?id=K4321229T8" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-lattes" viewBox="0 0 24 24" fill="currentColor"><title>Lattes</title><path d="M4.5888373,23.953341 c -1.35687,-3.473452 -2.6564614,-6.968849 -3.98391182,-10.453562 0.82060122,-0.40001 1.86172402,0.48543 2.79594432,0.472187 3.4935418,0.669352 7.3442842,0.819763 10.5832142,-0.879343 1.655498,-0.805934 3.051174,-2.447955 2.971168,-4.3718414 0.0819,-1.1944455 -0.74443,-2.1914898 -0.77307,-3.3561754 0.603113,-0.093579 1.445775,1.3493574 2.017736,1.9660473 1.747449,2.3074771 2.210962,5.5982035 0.831857,8.1964585 -1.712604,3.67722 -5.418181,5.932705 -9.1326555,7.195289 -1.6878542,0.576243 -3.4350239,0.964996 -5.1900362,1.265385 l -0.120246,-0.03445 z M 8.4880405,13.973514 C 5.8767015,13.470966 3.2465584,13.071237 0.63852883,12.550992 -0.10156498,9.9645292 -0.32698753,7.1145421 0.5190428,4.5248351 1.2506947,2.4191037 3.0347435,0.70291159 5.2374792,0.2285698 8.4247677,-0.45249148 11.742167,0.44264667 14.628524,1.8104924 15.495157,1.9145936 15.544895,2.7860281 14.610189,2.5150825 12.370186,2.2146619 9.8039249,1.817573 7.8509768,3.2524982 6.3953317,4.6576658 6.6239947,6.880539 6.9551285,8.6923981 c 0.333564,1.7613309 0.9796561,3.4425989 1.6634252,5.0931099 0.032747,0.07411 -0.026521,0.227303 -0.1305132,0.188006 z M 12.325941,11.058302 C 10.077888,10.894542 7.8111267,8.9548106 7.9813769,6.5766545 c 0.2119,-1.5370194 1.9751697,-2.4368006 3.4040081,-2.0224832 1.964467,0.3624585 3.915987,1.9852656 3.993392,4.0843639 -0.04041,1.3302553 -1.253251,2.4049378 -2.56387,2.4104958 l -0.244313,0.01486 -0.244653,-0.0056 z"/></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Bioestatística com R - 2 - Usando e manipulando tabelas</h1>
      <div class="post-meta">
        
      </div>
    </header>
    <div class="post-content">
      <p>Nesse segundo tutorial, o foco é em importação e exportação de dados pra arquivos, além de como fazer as manipulações mais comuns nas suas tabelas: filtrar de acordo com critérios, criar, renomear e remover colunas, extrair resumos dos dados, entre outras coisas mais. Todas as tabelas usadas nos exemplos estão nessa <a href="https://www.dropbox.com/sh/pb9fsbex5hh4nw3/AADxjjUGC5gUUvfM4vs8M6zwa?dl=0">pasta compartilhada</a>.</p>
<p><a href="/ensino/tutoriais-bioestatistica/bioestatistica1">Parte 1</a></p>
<p><a href="/ensino/tutoriais-bioestatistica/bioestatistica2">Parte 2</a></p>
<p><a href="/ensino/tutoriais-bioestatistica/bioestatistica3">Parte 3</a></p>
<p><a href="/ensino/tutoriais-bioestatistica/bioestatistica4">Parte 4</a></p>
<hr>
<h3 id="importando-e-exportando-dados">Importando e exportando dados</h3>
<p>Vamos começar do que é mais direto. Digamos que você tem um conjunto de dados que quer salvar num arquivo. Pra fins de armazenamento de dados nesse tutorial, vamos usar arquivos <strong>CSV</strong> (<em>comma-separated values</em>, de valores separados por vírgulas). Esses arquivos são arquivos texto normais, onde cada linha do arquivo vira uma linha da tabela e as colunas são separadas por vírgulas (ou qualquer outro caractere, digamos, ponto-e-vírgula). Então, podemos criar um conjunto de dados arbitrário em R. Conjuntos de dados são armazenados em variáveis do tipo <strong>data.frame</strong>. Pra criar um, você pode usar vetores como colunas:</p>
<pre tabindex="0"><code>numeros = c(1,2,3)
letras = c(&#34;a&#34;,&#34;b&#34;,&#34;c&#34;)
uns.dados = data.frame(
 coluna1 = numeros,
 coluna2 = letras
)
uns.dados
</code></pre><p>Se tudo deu certo, apareceu uma tabelinha, de 3 linhas, com os dados, embaixo de cada coluna tem o tipo da coluna (<strong>dbl</strong> pra <em>double</em>, o termo para números não-inteiros, com decimais e <strong>fctr</strong> pra caracteres/strings). Agora, pra salvar esses dados:</p>
<pre tabindex="0"><code>write.table(df, &#34;uns dados.csv&#34;, sep = &#34;;&#34;, row.names = F)
</code></pre><p>De novo, tudo dando certo, deve existir um arquivo chamado uns dados.csv na mesma pasta do seu arquivo R. Quem fez tudo foi a função <strong>write.table</strong>. A primeira coisa que você passa pra função <strong>write.table</strong> é o seu <strong>data.frame</strong>. Em seguida, o nome do arquivo (pode colocar a pasta e o resto do caminho se quiser salvar em outra pasta). Depois <strong>sep</strong> indica o caractere que separa as colunas. O “normal” é usar vírgula mesmo, como diz o nome do arquivo. Mas aqui no Brasil, por exemplo, a vírgula é usada pra separar as casas decimais, o que pode confundir na hora de ler o arquivo (em inglês, usa-se o ponto, então não é problema). Por isso eu prefiro usar ponto-e-vírgula sempre que dá. O último argumento, <strong>row.names</strong>, está colocado como FALSE, só pra que R não numere as linhas (esse seria comportamento dessa função se você colocasse TRUE ou não dissesse nada). E se quisermos agora abrir o arquivo que acabamos de salvar? A lógica diria que existe uma função inversa, <strong>read.table</strong> que lê arquivos, mais ou menos nos mesmos moldes. O argumento <strong>header</strong> diz pra função que a primeira linha da tabela é o “cabeçalho”, contendo os nomes das colunas.</p>
<pre tabindex="0"><code>dados.lidos = read.table(&#34;uns dados.csv&#34;, sep = &#34;;&#34;, header = T)
dados.lidos
</code></pre><p>E voilá. Você diz o nome e onde está o arquivo e qual o caractere que separa colunas e pronto! Agora faremos operações sobre os dados.</p>
<h3 id="descrevendo-os-dados">Descrevendo os dados</h3>
<p>Primeiro, a gente tem que usar o que vimos ainda agora pra obter dados mais interessantes do que esses inventados. A tabela que usaremos pode ser baixada <a href="https://www.dropbox.com/sh/pb9fsbex5hh4nw3/AADxjjUGC5gUUvfM4vs8M6zwa?dl=0">aqui</a>: <strong>clinicaltrial.csv</strong> Essa tabela tem dados inventados e simplificados sobre um clinical trial de uma droga pisquiátrica qualquer. Ele possui 6 colunas:</p>
<ul>
<li><em>gender</em>: masculino/feminino</li>
<li><em>treatment</em>: grupo placebo ou droga ativa (SSRI - <em>Selective Serotonin Reuptake Inhibitor</em> - uma classe de drogas psiquiátricas)</li>
<li><em>age</em>: idade</li>
<li><em>doing.therapy</em>: se a pessoa está ou não fazendo terapia ao mesmo tempo</li>
<li><em>scale.before</em>: severidade do transtorno antes do tratamento, medida por uma escala</li>
<li><em>scale.after</em>: severidade do transtorno ao final do tratamento, medida pela mesma escala</li>
</ul>
<p>O objetivo aqui é aprender a extrair médias e medianas, desvios e variâncias, pra diferentes subgrupos. Tem umas coisas que precisamos saber antes. Primeiro, carregamos a tabela (lembre-se que pra funcionar, a tabela tem que estar na mesma pasta do notebook, senão você precisa dizer a pasta também, o caminho inteiro, e não só o nome do arquivo):</p>
<pre tabindex="0"><code>ct.data = read.table(&#34;clinicaltrial.csv&#34;, sep=&#34;;&#34;, header = T)
summary(ct.data)
</code></pre><p>A função <strong>summary</strong> dá um resumo da tabela, útil pra checarmos se saiu tudo direitinho. Por exemplo, são 297 mulheres e 324 homens, idades vão de 22 a 45 e o valor na escala antes do estudo varia de 4 a 10, com média 7,129. Agora, e se quisermos armazenar a média das idades em uma variável? Pra extrair uma coluna de uma tabela, usamos o símbolo <strong>$</strong>.Porexemplo, <strong>ct.data$age</strong> te dá a lista de valores da coluna <strong>age</strong>. E R possui uma função <strong>mean()</strong> que calcula médias (e várias outras).</p>
<pre tabindex="0"><code>mean(ct.data$age)
</code></pre><p>Nada muito diferente se quisermos a mediana, o desvio padrão ou a variância.</p>
<pre tabindex="0"><code>median(ct.data$age)
sd(ct.data$age)
var(ct.data$age)
</code></pre><h3 id="dplyr">dplyr</h3>
<p>Agora, pra complicar um pouco. E se quisermos a média de idade só pra mulheres? Pra esse tipo de tarefa, podemos proceder de alguns jeitos diferentes. Aqui, usaremos uma biblioteca chamada <strong>dplyr</strong>. Uma biblioteca é um pedaço de código em R, um conjunto de funções e outras coisas úteis que são agrupadas pra serem usadas como um pacote: <strong>dplyr</strong> contém funções pra manipulação de data.frames, em outro momento usaremos um outro pacote pra fazer gráficos, etc. Existem muitos muitos pacotes, pra coisas bem específicas e todo tipo de análise, feitos por pessoas de todo o planeta. Esse é um dos pontos fortes de R. Pra instalar <strong>dplyr</strong> (ou qualquer outra biblioteca):</p>
<pre tabindex="0"><code>install.packages(&#34;dplyr&#34;)
</code></pre><p>Uma vez instalado, sempre que for usar, você precisa importar a biblioteca (ignorem os avisos que vão aparecer):</p>
<pre tabindex="0"><code>library(dplyr)
</code></pre><p>O que <strong>dplyr</strong> nos dá é um operador novo e um conjunto de funções úteis. Por exemplo, as que usaremos hoje:</p>
<ul>
<li>a função <strong>mutate</strong>, pra adicionar colunas;</li>
<li>a função <strong>rename</strong>, pra renomear colunas;</li>
<li>a função <strong>filter</strong>, pra selecionar só algumas linhas da tabela de acordo com critérios;</li>
<li>a função <strong>select</strong>, pra gerar uma nova tabela só com algumas colunas selecionadas;</li>
<li>a função <strong>group_by</strong>, pra separar uma tabela em subtabelas seguindo algum critério;</li>
<li>a função <strong>summarise</strong>, pra gerar medidas descritivas de conjuntos de dados (tipo média, desvio, etc);</li>
<li>o operador <strong>%&gt;%</strong>, pra passar tabelas pras funções ou pegar o resultado de uma função e passar pra seguinte.</li>
</ul>
<p>As descrições acima são só pra referência, veremos uma por uma agora.</p>
<h3 id="manipulando-dados">Manipulando dados</h3>
<p>Voltemos ao problema anterior: queremos a média de idade das mulheres no estudo. Esse é um trabalho pra função <strong>filter</strong>. Veja uma maneira de usar:</p>
<pre tabindex="0"><code>mulheres = ct.data %&gt;% 
 filter(gender == &#34;female&#34;)
media.idade.mulheres = mean(mulheres$age)
media.idade.mulheres

[1] 33.74411
</code></pre><p>Intuitivo? Primeiro, criamos uma nova tabela, mulheres, que contém só as mulheres da tabela original. Isso é obtido com <strong>dplyr</strong>: os dados originais (<strong>ct.data</strong>) são passados (com <strong>%&gt;%</strong>) pra função <strong>filter</strong>, que usa como critério o gênero (coluna <strong>gender</strong>) ser igual a (==) <strong>“female”</strong>. Depois é só calcular a média das idades, como antes. Legal. Mais complicado. E se quisermos a idade média das mulheres que faziam terapia? E das que não faziam? Tente você mesmo antes de ver como fazer abaixo (basta usar os operadores lógicos que vimos antes: E, OU, NÃO)</p>
<pre tabindex="0"><code>mulheres.terapia = ct.data %&gt;% 
 filter(gender == &#34;female&#34; &amp; doing.therapy)
mulheres.nao.terapia = ct.data %&gt;% 
 filter(gender == &#34;female&#34; &amp; !doing.therapy)


mean(mulheres.terapia$age)
[1] 33.93396

mean(mulheres.nao.terapia$age)
[1] 33.63874
</code></pre><p>Ok. Agora, digamos que estamos interessados só nas escalas, não mais na idade. Então quero uma tabela nova que não tenha a coluna de idade. Pra isso, a função select é o que queremos.</p>
<pre tabindex="0"><code>wdata = ct.data %&gt;%
 select(gender,treatment,doing.therapy,scale.before,scale.after)
wdata = ct.data %&gt;%
 select(-age)
names(wdata)
</code></pre><p>O que aconteceu acima: pra função <strong>select</strong>, você pode especificar que colunas quer manter ou que colunas quer remover (com o sinal de menos). A função <strong>names</strong> diz que colunas existem, só pra checar se deu certo. E o nome da variável é <strong>wdata</strong> de <em>working data</em>, os dados de trabalho, que estão em uso nesse momento (é só um nome que eu uso sempre quando falta um nome melhor). Agora, imagina que você não gosta dos nomes das colunas de escalas, quer mudar só pra <strong>before</strong> e <strong>after</strong>. Pra isso, a função <strong>rename</strong> existe.</p>
<pre tabindex="0"><code>wdata = ct.data %&gt;%
  rename(before = scale.before, after = scale.after)
names(wdata)
</code></pre><p>Próxima etapa. Queremos uma coluna nova - <strong>effect</strong> -, que indique a melhora do paciente no período, medido pela escala, ou seja, o valor da escala depois menos o valor da escala antes. A função <strong>mutate</strong> faz isso (o nome é porque ela muda, transforma a forma da tabela):</p>
<pre tabindex="0"><code>wdata = wdata %&gt;%
 mutate(effect = after - before)
</code></pre><p>Agora dá pra mostrar uma coisa que deixa <strong>dplyr</strong> muito mais divertida. Você pode encadear várias funções. O que fizemos em três partes acima, pode ser feito de uma vez só:</p>
<pre tabindex="0"><code>wdata = ct.data %&gt;%
 select(-age) %&gt;%
 rename(before = scale.before, after = scale.after) %&gt;%
 mutate(effect = after - before)
</code></pre><p>O código acima é equivalente ao que fizemos antes. Agora a gente tem a tabela nova, podemos voltar a extrair médias (ou qualquer outra medida), como antes. Por exemplo, qual a melhora média das melhora média das mulheres que fazem terapia ou tinham a escala &gt;= 8 antes do estudo?</p>
<pre tabindex="0"><code>subdata = wdata %&gt;%
 filter(gender == &#34;female&#34; &amp; (doing.therapy | before &gt;= 8))
mean(subdata$effect)
</code></pre><p>Ótimo. Última coisa. Todos essas médias que calculamos pra subgrupos específicos podem ser feitas de um jeito mais interessante, usando as funções <strong>group_by</strong> e <strong>summarise</strong>. A ideia é quebrar a tabela em grupos de acordo com algumas colunas e calcular alguma coisa pra cada grupo, devolvendo os resultados já sumarizados numa tabela nova. Exemplo. Digamos que queremos a média da melhora pra cada sexo.</p>
<pre tabindex="0"><code>medias = wdata %&gt;%
  group_by(gender) %&gt;%
  summarise(media = mean(effect))
medias
</code></pre><p>O resultado é uma tabela nova, que contém uma coluna pro sexo e outra pro resultado da média, que criamos na função. E se quisermos, além de separar por sexo, saber também as médias pra grupos placebo/tratamento ativo? E se quisermos saber também o desvio padrão, além da média?</p>
<pre tabindex="0"><code>medias = wdata %&gt;%
  group_by(gender, treatment) %&gt;%
  summarise(media = mean(effect), desvio = sd(effect))
medias
</code></pre><p>Pronto. Nova tabela, com os resultados pra cada grupo.</p>
<hr>
<p>É isso. Vimos como importar tabelas, usamos e abusamos de <strong>dplyr</strong> pra fazer o que quiser com os dados pra prepará-los pra análise (aqui só calculamos médias, mas vamos fazer algo mais sofisticado em breve).</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
